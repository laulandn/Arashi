/*/     Project Arashi: VAPixProcs.c     Major release: Version 1.1.1, 3/17/95     Last modification: Wednesday, September 9, 1992, 21:42     Created: Thursday, February 9, 1989, 21:21     Copyright © 1989-1992, Juri Munkki/*/#include "VA.h"#include "VAInternal.h"void	VAPixel(x,y)register	int		x,y;{	register	long	*p;	short *s;  RGBColor c;	if(VA.numpix[VA.curbuffer]<MAXSAVEDPIX)	{	VA.pixcolors[VA.curbuffer][VA.numpix[VA.curbuffer]]=VA.color;	    VA.pixx[VA.curbuffer][VA.numpix[VA.curbuffer]]=x; VA.pixy[VA.curbuffer][VA.numpix[VA.curbuffer]]=y;		p=VA.pix[VA.curbuffer]+VA.numpix[VA.curbuffer]++;		#ifdef ORIG_ARASHI	asm	{		move.l	VA.quickrow,A1		;	Pointer to base address table		move.l	(0,A1,y.w*4),A0		;	Get pointer to row base		add.w	x,A0				;	Add x to base address		move.l	A0,(p)		}#else/*    c.red=0xffff; c.green=0x0000; c.blue=0x0000;    RGBForeColor(&c);    MoveTo(x,y);    LineTo(x+1,y+1);*/#endif	}}void	VASafePixel(x,y)register	int	x,y;{	register	long	*p;  RGBColor c;	if(VA.numpix[VA.curbuffer]<MAXSAVEDPIX)	{	if(x<VA.frame.left)	return;		if(x>=VA.frame.right)	return;		if(y<VA.frame.top)	return;		if(y>=VA.frame.bottom)return;		{	VA.pixcolors[VA.curbuffer][VA.numpix[VA.curbuffer]]=VA.color;	        VA.pixx[VA.curbuffer][VA.numpix[VA.curbuffer]]=x; VA.pixy[VA.curbuffer][VA.numpix[VA.curbuffer]]=y;			p=VA.pix[VA.curbuffer]+VA.numpix[VA.curbuffer]++;			#ifdef ORIG_ARASHI		asm	{			move.l	VA.quickrow,A1		;	Pointer to base address table			move.l	(0,A1,y.w*4),A0		;	Get pointer to row base			add.w	x,A0				;	Add x to base address			move.l	A0,(p)			}#else/* used for enemy trails */    /*c.red=0x0000; c.green=0xffff; c.blue=0x0000;    RGBForeColor(&c);    MoveTo(x,y);    LineTo(x+1,y+1);*/#endif		}	}}void	VAPlotPixels(count,pixels,colors,bnum)int		count;long	*pixels;int		*colors;int		bnum;{#ifdef ORIG_ARASHIasm	{		movem.l	D5/A2,-(sp)		move.w	count,D2		subq.w	#1,D2		bmi.s	@nopix		move.l	pixels,A2		move.l	colors,A1		move.l	VA.offset,D0		move.w	VA.field,D5	;	Field width to D5@loop		move.l	(A2)+,A0	;	Read next address		move.w	(A1)+,D1	;	Read next VA.color		dc.l	0xEFD01825	;	BFINS	BitValue,(RowBase){OffSet:4}		dbra	D2,@loop		@nopix		movem.l	(sp)+,D5/A2	}#else  unsigned int t;  unsigned short x,y;  RGBColor c;  for(t=0;t<count;t++) {    c.red=0x0000; c.green=0xffff; c.blue=0x0000;    RGBForeColor(&c);    x=VA.pixx[bnum][t]; y=VA.pixy[bnum][t];    MoveTo(x,y);    LineTo(x+1,y+1);  }#endif}void	VAErasePixels(count,pixels,bnum)int		count;long	*pixels;int		bnum;{#ifdef ORIG_ARASHIasm	{		move.l	D5,-(sp)		move.w	count,D2		subq.w	#1,D2		bmi.s	@nopix		move.l	pixels,A1		move.l	VA.offset,D0		move.w	VA.field,D1	;	Field width to D5@loop		move.l	(A1)+,A0	;	Read next address		dc.l	0xEED01821	;	BFINS	BitValue,(RowBase){OffSet:4}		dbra	D2,@loop		@nopix		move.l	(sp)+,D5	}#else  unsigned int t;  unsigned short x,y;  RGBColor c;  for(t=0;t<count;t++) {    c.red=0x0000; c.green=0x0000; c.blue=0x0000;    RGBForeColor(&c);    x=VA.pixx[bnum][t]; y=VA.pixy[bnum][t];    MoveTo(x,y);    LineTo(x+1,y+1);  }#endif}void	VASpot(x,y)register	int	x,y;{	register	long	*p;  RGBColor c;	y--;	if(VA.numspots[VA.curbuffer]<MAXSAVEDPIX)	{	VA.spotcolors[VA.curbuffer][VA.numspots[VA.curbuffer]]=VA.color;	    VA.spotsx[VA.curbuffer][VA.numspots[VA.curbuffer]]=x; VA.spotsy[VA.curbuffer][VA.numspots[VA.curbuffer]]=y;		p=VA.spots[VA.curbuffer]+VA.numspots[VA.curbuffer]++;		#ifdef ORIG_ARASHI	asm	{		move.l	VA.quickrow,A1		;	Pointer to base address table		move.l	(0,A1,y.w*4),A0		;	Get pointer to row base		add.w	x,A0				;	Add x to base address		move.l	A0,(p)		}#else/* used for shots */    /*c.red=0x0000; c.green=0x0000; c.blue=0xffff;    RGBForeColor(&c);    MoveTo(x,y);    LineTo(x+1,y+1);*/#endif	}}void	VASafeSpot(x,y)register	int	x,y;{	register	long	*p;  RGBColor c;	y--;	if(VA.numspots[VA.curbuffer]<MAXSAVEDPIX)	{	if(x<=VA.frame.left)		return;		if(x>=VA.frame.right-2)	return;		if(y<=VA.frame.top)		return;		if(y>=VA.frame.bottom-2)	return;		{	VA.spotcolors[VA.curbuffer][VA.numspots[VA.curbuffer]]=VA.color;	        VA.spotsx[VA.curbuffer][VA.numspots[VA.curbuffer]]=x; VA.spotsy[VA.curbuffer][VA.numspots[VA.curbuffer]]=y;			p=VA.spots[VA.curbuffer]+VA.numspots[VA.curbuffer]++;			#ifdef ORIG_ARASHI		asm	{			move.l	VA.quickrow,A1		;	Pointer to base address table			move.l	(0,A1,y.w*4),A0		;	Get pointer to row base			add.w	x,A0				;	Add x to base address			move.l	A0,(p)			}#else/* used for stars */    /*c.red=0x0000; c.green=0xffff; c.blue=0xffff;    RGBForeColor(&c);    MoveTo(x,y);    LineTo(x+1,y+1);*/#endif		}	}}void	VAPlotSpots(count,pixels,colors,bnum)int		count;long 	*pixels;int		*colors;int		bnum;{#ifdef ORIG_ARASHIasm	{		movem.l	D3-D5/A2,-(sp)		move.w	count,D2		subq.w	#1,D2		bmi.s	@nopix		move.w	VA.row,D4		subq.w	#1,D4		moveq.l	#8,D5		move.l	pixels,A2		move.l	colors,A1		move.l	VA.offset,D0		move.w	VA.field,D3	;	Field width to D5@loop		move.w	(A1)+,D1	;	Read next VA.color		move.l	(A2)+,A0	;	Read next address		dc.l	0xEFD01823	;	BFINS	VA.color,(RowBase){OffSet:field}		add.w	D4,A0		dc.l	0xEFD01823	;	BFINS	VA.color,(RowBase){OffSet:field}		add.l	D5,D0		dc.l	0xEFD01823	;	BFINS	VA.color,(RowBase){OffSet:field}		add.l	D5,D0		dc.l	0xEFD01823	;	BFINS	VA.color,(RowBase){OffSet:field}		add.w	D4,A0		dc.l	0xEFD01823	;	BFINS	VA.color,(RowBase){OffSet:field}		sub.l	D5,D0		sub.l	D5,D0		dbra	D2,@loop		@nopix		movem.l	(sp)+,D3-D5/A2	}#else  unsigned int t;  unsigned short x,y;  RGBColor c;  for(t=0;t<count;t++) {    c.red=0xffff; c.green=0x0000; c.blue=0x0000;    RGBForeColor(&c);    x=VA.spotsx[bnum][t]; y=VA.spotsy[bnum][t];    MoveTo(x,y);    LineTo(x+1,y+1);  }#endif}void	VAEraseSpots(count,pixels,bnum)int		count;long	*pixels;int		bnum;{#ifdef ORIG_ARASHIasm	{		movem.l	D3-D5,-(sp)		move.w	VA.row,D4		subq.w	#1,D4		moveq.l	#8,D5		move.w	count,D2		move.l	pixels,A1		move.l	VA.offset,D0		move.w	VA.field,D3	;	Field width to D5		subq.w	#1,D2		bmi.s	@nopix@loop		move.l	(A1)+,A0	;	Read next address		dc.l	0xEED00823	;	BFTST	(RowBase){OffSet:field}		add.w	D4,A0		dc.l	0xEED00823	;	BFTST	(RowBase){OffSet:field}		add.l	D5,D0		dc.l	0xEED00823	;	BFTST	(RowBase){OffSet:field}		add.l	D5,D0		dc.l	0xEED00823	;	BFTST	(RowBase){OffSet:field}		add.w	D4,A0		dc.l	0xEED00823	;	BFTST	(RowBase){OffSet:field}		sub.l	D5,D0		sub.l	D5,D0		dbra	D2,@loop		@nopix		movem.l	(sp)+,D3-D5	}#else  unsigned int t;  unsigned short x,y;  RGBColor c;  for(t=0;t<count;t++) {    c.red=0x0000; c.green=0x0000; c.blue=0x0000;    RGBForeColor(&c);    x=VA.spotsx[bnum][t]; y=VA.spotsy[bnum][t];    MoveTo(x,y);    LineTo(x+1,y+1);  }#endif}