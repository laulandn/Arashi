/*/     Project Arashi: VA7Segment.c     Major release: Version 1.1.1, 3/17/95     Last modification: Wednesday, September 9, 1992, 21:40     Created: Friday, March 24, 1989, 15:07     Copyright © 1989-1992, Juri Munkki/*//***	These routines are a precursor to the 14 segment**	display routines. I left them here, because it is**	faster to draw the numbers with just 8 segments.****	Your digital watch might have the same kind of**	numbers that these routines produce.****	The 14 segment routines are better documented and**	somewhat similar to the following.*/#include "VA.h"#include "VAInternal.h"/*#define USE_MAC_FONT 1*/char	numbers[]={	1+2+4+8+16+32,		/*	0	*/					  2+4,				/*	1	*/					1  +4+8   +32+64,	/*	2	*/					1+2+4+8      +64,	/*	3	*/					  2+4  +16   +64,	/*	4	*/					1+2  +8+16   +64,	/*	5	*/					1+2  +8+16+32+64,	/*	6	*/					  2+4+8,			/*	7	*/					1+2+4+8+16+32+64,	/*	8	*/					1+2+4+8+16   +64,	/*	9	*/					0};void	VADrawSegments(x,y,code)int		x,y,code;{#ifdef ORIG_ARASHI	asm	{				move.l	D3,-(SP)			move.w	code,D3			move.l	VA.base,A0			move.w	y,D0			move.w	VA.row,D1			mulu.w	D1,D0			add.l	D0,A0			add.w	x,A0			addq.l	#1,A0						moveq.l	#-1,D0			move.w	VA.segmscale,D2			ror.w	#1,D3			bcc.s	@seg0			move.w	VA.color,D0	@seg0				move.b	D0,(A0)+			dbra	D2,@seg0						sub.w	D1,A0			moveq.l	#-1,D0			move.w	VA.segmscale,D2			ror.w	#1,D3			bcc.s	@seg1			move.w	VA.color,D0	@seg1			move.b	D0,(A0)			sub.w	D1,A0			dbra	D2,@seg1						sub.w	D1,A0			moveq.l	#-1,D0			move.w	VA.segmscale,D2			ror.w	#1,D3			bcc.s	@seg2			move.w	VA.color,D0	@seg2			move.b	D0,(A0)			sub.w	D1,A0			dbra	D2,@seg2						moveq.l	#-1,D0			move.w	VA.segmscale,D2			ror.w	#1,D3			bcc.s	@seg3			move.w	VA.color,D0	@seg3			move.b	D0,-(A0)			dbra	D2,@seg3						subq.l	#1,A0			add.w	D1,A0			moveq.l	#-1,D0			move.w	VA.segmscale,D2			ror.w	#1,D3			bcc.s	@seg4			move.w	VA.color,D0	@seg4			move.b	D0,(A0)			add.w	D1,A0			dbra	D2,@seg4						move.l	A0,A1			add.w	D1,A0			moveq.l	#-1,D0			move.w	VA.segmscale,D2			ror.w	#1,D3			bcc.s	@seg5			move.w	VA.color,D0	@seg5			move.b	D0,(A0)			add.w	D1,A0			dbra	D2,@seg5						addq.l	#1,A1			moveq.l	#-1,D0			move.w	VA.segmscale,D2			ror.w	#1,D3			bcc.s	@seg6			move.w	VA.color,D0	@seg6			move.b	D0,(A1)+			dbra	D2,@seg6			move.l	(sp)+,D3		}#else  int thePat=0;  int theScale=VA.segmscale;  int dubScale=theScale*2;  x-=theScale;  y-=dubScale;  /**/  /* horiz bot */  if(code&1) thePat=DRAWMODETEXT;  else thePat=DRAWMODEDARK;  PenMode(thePat);  MoveTo(x+1,y+dubScale);  LineTo(x+theScale-1,y+dubScale);  /**/  /* vert right bot */  if(code&2) thePat=DRAWMODETEXT;  else thePat=DRAWMODEDARK;  PenMode(thePat);  MoveTo(x+theScale,y+theScale+1);  LineTo(x+theScale,y+dubScale-1);  /**/  /* vert right top */    if(code&4) thePat=DRAWMODETEXT;  else thePat=DRAWMODEDARK;  PenMode(thePat);  MoveTo(x+theScale,y+1);  LineTo(x+theScale,y+theScale-1);  /**/  /* horiz top */  if(code&8) thePat=DRAWMODETEXT;  else thePat=DRAWMODEDARK;  PenMode(thePat);  MoveTo(x+1,y);  LineTo(x+theScale-1,y);  /**/  /* vert left bot */  if(code&32) thePat=DRAWMODETEXT;  else thePat=DRAWMODEDARK;  PenMode(thePat);  MoveTo(x,y+theScale+1);  LineTo(x,y+dubScale-1);  /**/  /* vert left top */  if(code&16) thePat=DRAWMODETEXT;  else thePat=DRAWMODEDARK;  PenMode(thePat);  MoveTo(x,y+1);  LineTo(x,y+theScale-1);  /**/  /* horiz  center */  if(code&64) thePat=DRAWMODETEXT;  else thePat=DRAWMODEDARK;  PenMode(thePat);  MoveTo(x+1,y+theScale);  LineTo(x+theScale-1,y+theScale);  /**/#endif}void	VADrawNumber(num,x,y)register	long	num;register	int		x,y;{	register	int		dig,neg;				/*int		mode;*/char s;	/*mode=QD32COMPATIBLE;*/	/*SwapMMUMode(&mode);*/#ifndef USE_MAC_FONT#else	TextMode(DRAWMODETEXT);    TextSize(18);#endif	if(num<0)	{	num=-num;		neg=-1;	}	else	{	neg=0;	}	do	{	dig= num % 10;		num/=10;#ifndef USE_MAC_FONT		VADrawSegments(x,y,numbers[dig]);#else  s='0'+dig;  MoveTo(x,y+30);  DrawText(&s,0,1);#endif		x-= VA.segmscale + 7;	}	while(num!=0 && x>0);	if(x>0 && neg)#ifndef USE_MAC_FONT		VADrawSegments(x,y,64);#else  s='-';  MoveTo(x,y+30);  DrawText(&s,0,1);#endif	/*SwapMMUMode(&mode);*/}void	VADrawPadNumber(num,x,y,width)register	long	num;register	int		x,y,width;{	register	int		dig,neg;				/*int		mode;*/char s;	/*mode=QD32COMPATIBLE;*/	/*SwapMMUMode(&mode);*/#ifndef USE_MAC_FONT#else	TextMode(DRAWMODETEXT);    TextSize(18);#endif	if(num<0)	{	num=-num;		neg=-1;	}	else	{	neg=0;	}	do	{	dig= num % 10;		num/=10;#ifndef USE_MAC_FONT		VADrawSegments(x,y,numbers[dig]);#else  s='0'+dig;  MoveTo(x,y+30);  DrawText(&s,0,1);#endif		x-= VA.segmscale + 7;	}	while(num!=0 && x>0 && --width);		if(x>0 && neg && --width>0)	{	#ifndef USE_MAC_FONT	VADrawSegments(x,y,64);#else  s='-';  MoveTo(x,y+30);  DrawText(&s,0,1);#endif		x-= VA.segmscale + 7;	}	while(--width>0 && x>0)	{	#ifndef USE_MAC_FONT	VADrawSegments(x,y,0);#else  /* erase all...not yet... */#endif		x-= VA.segmscale + 7;	}	/*SwapMMUMode(&mode);*/}